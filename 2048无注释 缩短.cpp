#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <math.h>
#include <conio.h> 
void gamestart();int gameover(int result);void printmap(int(*data)[4]);int randomnum();void creatnewnum(int(*data)[4]);void up(int(*data)[4], int test);void down(int(*data)[4]);void left(int(*data)[4], int test);void right(int(*data)[4]);void moveup(int(*data)[4]);void movedown(int(*data)[4]);void moveright(int(*data)[4]);void moveleft(int(*data)[4]);int cheakmap(int(*data)[4]);int judgecontinue(int(*data)[4]);int grade = 0;int main(){int result = 1,again = 1;gamestart();for (; again;){system("cls");grade = 0; int data[4][4] = { 0 },line, row;srand((unsigned int)time(NULL));for (int times = 0; times < 3; times++) {line = rand() % 4;row = rand() % 4;data[line][row] = ((rand() % 2) + 1) * 2;}for (;;){printmap(data);for (int correct = 0; correct == 0;){char control = _getch(); switch (control){case 'w':up(data, 1);correct = 1;break;case 's':down(data);correct = 1;break;case 'a':left(data, 1);correct = 1;break;case 'd':right(data);correct = 1;break;default:correct = 0;break;}fflush(stdin);}system("cls");result = cheakmap(data);int judge;if (result == 0){judge = 1;creatnewnum(data);}else if (result == -1){printmap(data);break;}else if (result == 1){judge = judgecontinue(data);}if (judge == 0){printmap(data);break;}}again = gameover(result);}return 0;}
void gamestart(){printf("\"2048\"\n游戏玩法：wasd控制数字上下左右移动，数字相同时会合并叠加，当凑够2048时即获胜~~\n我看好你哦，亲~~\nby 飞火流星\n");_getch();}int gameover(int result){if (result == -1){printf("不错哦~ 挺猛的~~\n");}else if (result == 1){printf("挂了吧~~ 23333333333\n");}for (;;){printf("再来一发？ (Y/N):");char YN;scanf("%c", &YN);fflush(stdin);if (YN == 'N' || YN == 'n'){printf("就知道你没种 哼~ hhhhhhhhhhh\n");system("pause");return 0;}else if (YN == 'Y' || YN == 'y'){return 1;}}}int randomnum(){int num;srand((unsigned int)time(NULL));num = ((rand() % 2) + 1) * 2;return num;}
void creatnewnum(int(*data)[4]) {int emptylocalline[16] = { 0 }, emptylocalrow[16] = { 0 }, count = 0, line, row;for (line = 0, row = 0; line < 4; line++){for (row = 0; row < 4; row++){if (data[line][row] == 0){emptylocalline[count] = line;emptylocalrow[count] = row;count++;}}}int creattimes = rand() % 3 + 1;for (int cnt = 0; cnt < creattimes; cnt++){int creatlocal = rand() % count;line = emptylocalline[creatlocal];row = emptylocalrow[creatlocal];data[line][row] = randomnum();}}void printmap(int(*data)[4]){char board[4][4][5] = {0};for(int line = 0, row = 0; row < 4; row++){for (line = 0; line < 4; line++){itoa(data[line][row],board[line][row],10);}}for(int line = 0, row = 0; row < 4; row++){for (line = 0; line < 4; line++){if(board[line][row][0] == '0'){board[line][row][0] = 0;}}}
printf("┌─────┬─────┬─────┬─────┐\n│          │          │          │          │\n│          │          │          │          │\n│%5s     │%5s     │%5s     │%5s     │\n│          │          │          │          │\n│          │          │          │          │\n├─────┼─────┼─────┼─────┤\n│          │          │          │          │\n│          │          │          │          │\n│%5s     │%5s     │%5s     │%5s     │\n│          │          │          │          │\n│          │          │          │          │\n├─────┼─────┼─────┼─────┤\n│          │          │          │          │\n│          │          │          │          │\n│%5s     │%5s     │%5s     │%5s     │\n│          │          │          │          │\n│          │          │          │          │\n├─────┼─────┼─────┼─────┤\n│          │          │          │          │\n│          │          │          │          │\n│%5s     │%5s     │%5s     │%5s     │\n│          │          │          │          │\n│          │          │          │          │\n└─────┴─────┴─────┴─────┘\n",
board[0][0], board[0][1], board[0][2], board[0][3],board[1][0], board[1][1], board[1][2], board[1][3],board[2][0], board[2][1], board[2][2], board[2][3],board[3][0], board[3][1], board[3][2], board[3][3]);printf("Score:%d\n", grade);}
void up(int(*data)[4], int test){moveup(data);int line = 0, row = 0;for (row = 0; row < 4; row++){for (line = 0; line < 3; line++){if (data[line][row] == data[line + 1][row]){data[line][row] = data[line][row] * 2;if (test){grade += data[line][row];}data[line + 1][row] = 0;}}}moveup(data);}void down(int(*data)[4]){movedown(data);int line = 3, row = 0;for (row = 0; row < 4; row++){for (line = 3; line > 0; line--){if (data[line][row] == data[line - 1][row]){data[line][row] = data[line][row] * 2;grade += data[line][row];data[line - 1][row] = 0;}}}movedown(data);}void left(int(*data)[4], int test){moveleft(data);int line = 0, row = 0;for (line = 0; line < 4; line++){for (row = 0; row < 3; row++){if (data[line][row] == data[line][row + 1]){data[line][row] = data[line][row] * 2;if (test){grade += data[line][row];}data[line][row + 1] = 0;}}}moveleft(data);}void right(int(*data)[4]){moveright(data);int line = 0, row = 3;for (line = 0; line < 4; line++){for (row = 3; row > 0; row--){if (data[line][row] == data[line][row - 1]){data[line][row] = data[line][row] * 2;grade += data[line][row];data[line][row - 1] = 0;}}}moveright(data);}
void moveup(int(*data)[4]){int line = 0, row = 0,cnt = 0;for (line = 0, row = 0; row < 4; row++){int temp[4] = { 0 };for (line = 0, cnt = 0; line < 4; line++){if (data[line][row] != 0){temp[cnt] = data[line][row];cnt++;data[line][row] = 0;}}for (line = 0, cnt = 0; line < 4; line++){data[line][row] = temp[cnt];cnt++;}}}void movedown(int(*data)[4]) {int line = 0, row = 0,cnt = 0;for (line = 3, row = 0; row < 4; row++){int temp[4] = { 0 };for (line = 3, cnt = 0; line >= 0; line--){if (data[line][row] != 0){temp[cnt] = data[line][row];cnt++;data[line][row] = 0;}}for (line = 3, cnt = 0; line >= 0; line--){data[line][row] = temp[cnt];cnt++;}}}void moveleft(int(*data)[4]) {int line = 0, row = 0,cnt = 0;for (line = 0, row = 0; line < 4; line++){int temp[4] = { 0 };for (row = 0, cnt = 0; row < 4; row++){if (data[line][row] != 0){temp[cnt] = data[line][row];cnt++;data[line][row] = 0;}}for (row = 0, cnt = 0; row < 4; row++){data[line][row] = temp[cnt];cnt++;}}}void moveright(int(*data)[4]) {int line = 0, row = 0,cnt = 0;for (line = 0, row = 0; line < 4; line++){int temp[4] = { 0 };for (row = 3, cnt = 0; row >= 0; row--){if (data[line][row] != 0){temp[cnt] = data[line][row];cnt++;data[line][row] = 0;}}for (row = 3, cnt = 0; row >= 0; row--){data[line][row] = temp[cnt];cnt++;}}}
int cheakmap(int(*data)[4]){int line = 0, row = 0,full = 1;for (line = 0, row = 0; line < 4; line++){for (row = 0; row < 4; row++){if (data[line][row] == 2048){full = -1;break;}}if (full == -1){break;}}for (line = 0, row = 0; line < 4 && full != -1; line++)	{for (row = 0; row < 4; row++){if (data[line][row] == 0) {full = 0;break;}}if (full == 0){break;}}if (full == 1){return 1;}else if (full == 0){return 0;}else if (full == -1){return -1;}}int judgecontinue(int(*data)[4]) {int judge,temp[4][4];for (int line = 0, row = 0; line < 4; line++) {for ( row = 0; row < 4; row++){temp[line][row] = data[line][row];}}up(temp, 0);judge = cheakmap(temp);if (judge == 0){return  1;}left(temp, 0);judge = cheakmap(temp);if (judge == 0)	{return 1;}return 0;}
