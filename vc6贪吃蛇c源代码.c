#include<stdio.h>
#include<windows.h>
#include<stdlib.h>
#include<conio.h>

#define HENG 80
#define SHU 25  //HENG是宽度，SHU是高度
#define TIME 400 //初始速度

void Gotoxy(int x, int y);//光标
void Food(struct SHE *head);//food食物
int Move(struct SHE *head);//用于蛇的移动
int Panduan(struct SHE *head, int x, int y);//用于食物与失败条件的判断
struct SHE *Link(struct SHE *head);//蛇身增长
void FreeShe(struct SHE *head);//释放内存
void Gameover(void);//游戏失败画面，如果窗口大小不是80*25导致画面不协调可舍去
void Huitu(struct SHE *head);//绘图


int Fx, Fy;  //食物的位置
int fen;   //得分
int fang; //方向参数
int Tx, Ty;

//构造蛇身
struct SHE
{
	int x;
	int y;
	struct SHE *next;
};

int main(void)
{
	struct SHE *head = NULL;
	int temp;
	int times = TIME;
	char m;

	do
	{
		fen = 0;
		fang = 2;
		temp = fen;
		times = TIME;
		head = NULL;

		head = (struct SHE *)malloc(sizeof(struct SHE));
		head -> x = 40;
		head -> y = 13;
		head -> next = NULL;

		Food(head);
		
		while (1)
		{
			Huitu(head);
			Sleep(times);
			if (0 == Move(head))
			{
				FreeShe(head);
				Gameover();
				break;
			}
			if (temp < fen)
			{
				Food(head);
				temp = fen;
				if (times > 50)
				{
					times -=10;
				}
				else if (times > 20)
				{
					times -=1;
				}
				else
					;
			}
		}


		do
		{
			Gotoxy(19,21);
			printf("是否继续？Y/N:");
			scanf(" %c", &m);
			system("cls");//清屏
		} while (m != 'Y' && m != 'y' && m != 'n' && m != 'N');
	} while (m == 'Y' || m == 'y');

	return 0;
}


//绘图
void Huitu(struct SHE *head)
{
	int flag = 1;

	while (head != NULL)
	{
		Gotoxy(head -> x, head -> y);
		if (flag == 1)
		{
			printf("□");
		}
		else if (flag == 2)
		{
			printf("■");
		}
		else
			;
		Gotoxy(Tx, Ty);
		printf(" ");
		flag++;
		head = head -> next;
	}
}

//用于光标的移动
void Gotoxy(int x, int y)
{ 
  COORD coord; 
  coord.X = x; 
  coord.Y = y; 
  SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);
}

//食物位置构造
void Food(struct SHE *head)
{
	int flag = 0;
	struct SHE *pr = head;

	do
	{
		srand(GetTickCount()); //基于毫秒级的随机数产生办法，需头文件winbase.h, windows中设计程序可以用windows.h
		Fx = (rand()%40) * 2;
		Fy = (rand()%12) * 2;
		flag = 0;
		pr = head;
		while (pr != NULL) //防止食物位置与蛇形重合
		{
			if (pr -> x == Fx && pr -> y == Fy)
			{
				flag = 1;
				break;
			}
			pr = pr -> next;
		}
	} while (flag == 1);
	Gotoxy(Fx, Fy);
	printf("■");
}

//用于蛇的移动
int Move(struct SHE *head)
{
	char op;
	int tox, toy, flag, temp;
	
	if (kbhit())  //kbhit函数用于检查当前是否有键盘输入，若有则返回一个非0值，否则返回0，需头文件conio.h
	{
		op = getch();
		switch (op)
		{
			case 'w':
				if (fang != 3)
				fang = 1;
				break;
			case 'd':
				if (fang != 4)
				fang = 2;
				break;
			case 's':
				if (fang != 1)
				fang = 3;
				break;
			case 'a':
				if (fang != 2)
				fang = 4;
				break;
			default:
				break;
		}
	}
	
	switch (fang)
	{
		case 1:
			toy = (head -> y) - 1;
			tox = (head -> x);
			break;
		case 2:
			tox = (head -> x) + 2;
			toy = (head -> y);
			break;
		case 3:
			toy = (head -> y) + 1;
			tox = (head -> x);
			break;
		case 4:
			tox = (head -> x) - 2;
			toy = (head -> y);
			break;
		default:
			break;
	}
	flag = Panduan(head, tox, toy);
	if (flag == 0)
	{
		return 0; //game over
	}
	else if (flag == 1)
	{
		head = Link(head);
		fen++;
	}
	else
	{
		;
	}
	while (head != NULL)
	{
		temp = head -> x;
		head -> x = tox;
		tox = temp;

		temp = head -> y;
		head -> y = toy;
		toy = temp;

		head = head -> next;
	}
	return 1;
}

//用于食物与失败条件的判断
int Panduan(struct SHE *head, int x, int y)
{
	
	int flag = 1;
	
	if (x < 0 || x > HENG - 1 || y < 0 || y > SHU - 1)
	{
		return 0;  //撞墙
	}
	while (head != NULL)
	{
		if (head -> x == x && head -> y == y && flag != 1)
		{
			return 0; //咬到自己
		}
		flag++;
		if (head -> next == NULL)
		{
			Tx = head -> x;
			Ty = head -> y;
		}
		head = head -> next;
	}
	if (x == Fx && y == Fy)
	{
		return 1;//有食物
	}
	return 2;//无异常
}

//蛇身增长
struct SHE *Link(struct SHE *head)
{
	struct SHE *p, *pr;

	pr = head;//指针指向链的头head
	p = (struct SHE *)malloc(sizeof(struct SHE));//申请内存，创建新的节点
	if (p == NULL)
	{
		printf("发生错误！！！");
		exit(0);
	}
	if (head == NULL)//如果链是空的，新节点就是链的头
	{
		head = p;
	}
	else
	{
		while (pr -> next != NULL)
		{
			pr = pr -> next;//循环语句，将指针pr移到链的末尾
		}
		pr -> next = p;//新节点加到链的末尾
	}
	p -> x = Tx;////给新节点赋值
	p -> y = Ty;
	p -> next = NULL;///p->next 指向下一个元素，就相当于下一个元素的指针，指向空值，表示是尾。
	return head;
}

//释放内存
void FreeShe(struct SHE *head)
{
	struct SHE *pr = NULL;
	
	while (head != NULL)
	{
		pr = head;
		head = head -> next;
		free(pr);
	}
}

//游戏失败画面，如果窗口大小不是80*25导致画面不协调可舍去
void Gameover(void)
{
	int i,j;

	int a[SHU][HENG]={{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,0,0,0,0,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,1,1,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};
	
	Gotoxy(0, 0);
	for (i = 0; i < SHU; i++)
	{
		for (j = 0; j< HENG; j++)
		{
			if (a[i][j] == 0)
			{
				printf(" ");
			}
			else
			{
				printf("0");
			}
		}
	}

	Gotoxy(19, 20);
	printf("游戏最终得分是 %d 分！！！\n", fen);
}